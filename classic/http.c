/* * Copyright (c) 2020-2022 joshua stein <jcs@jcs.org> * * Permission to use, copy, modify, and distribute this software for any * purpose with or without fee is hereby granted, provided that the above * copyright notice and this permission notice appear in all copies. * * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. */#include <stdio.h>#include <string.h>#include "dnr.h"#include "http.h"#include "util.h"#include "wikipedia.h"struct url *url_parse(const char *str){	struct url *url = NULL;	char *buf, *scheme, *host, *path;	unsigned short port;	short ret, pos;	size_t len, schemelen, hostlen, pathlen;		len = strlen(str);	scheme = xmalloc(len + 1);	printf("Scheme %s\n", scheme);	if (scheme == NULL) {		printf("http: Failed allocating %ld", len + 1);		return NULL;	}	host = xmalloc(len + 1);	if (host == NULL) {		printf("http: Failed allocating %ld", len + 1);		xfree(&scheme);		return NULL;	}	printf("host %s\n", host);	path = xmalloc(len + 1);	if (path == NULL) {		printf("http: Failed allocating %ld", len + 1);		xfree(&host);		xfree(&scheme);		return NULL;	}	/* scheme://host:port/path */	ret = sscanf(str, "%[^:]://%[^:]:%d%s%n", scheme, host, &port, path,	  &pos);	if (ret == 4) {		if (pos > len)			panic("url_parse sscanf overflow");		goto consolidate;	}		/* scheme://host/path */	ret = sscanf(str, "%[^:]://%[^/]%s%n", scheme, host, path, &pos);	printf("Scheme %s\n", scheme);	printf("Host %s\n", host);	printf("Path %s\n", path);	if (ret == 3) {		if (pos > len)			panic("url_parse sscanf overflow");		if (strcmp(scheme, "http") == 0)			port = 80;		else if (strcmp(scheme, "https") == 0)			port = 443;		else			goto cleanup;		goto consolidate;	}	printf("Port %d\n", port);	goto cleanup;consolidate:	schemelen = strlen(scheme);	hostlen = strlen(host);	pathlen = strlen(path);		/*	 * Put everything in a single chunk of memory so the caller can just	 * free(url)	 */	len = sizeof(struct url) + schemelen + 1 + hostlen + 1 + pathlen + 1;	url = xmalloc(len);	if (url == NULL) {		printf("http: Failed allocating %ld for URL", len);		goto cleanup;	}		url->scheme = (char *)url + sizeof(struct url);	len = strlcpy(url->scheme, scheme, schemelen + 1);		url->host = url->scheme + len + 1;	len = strlcpy(url->host, host, hostlen + 1);	printf("Final URL url_parse %s\n", url->host);	url->path = url->host + len + 1;	len = strlcpy(url->path, path, pathlen + 1);	url->port = port;	cleanup:	xfree(&scheme);	xfree(&host);	xfree(&path);	printf("Cleanup\n");	return url;}char *url_encode(unsigned char *str){	char *ret = NULL;	size_t len, n;	bool encode = false;	char a, b;	encode:	for (n = 0, len = 0; str[n] != '\0'; n++) {		if ((str[n] >= 'A' && str[n] <= 'Z') ||		  (str[n] >= 'a' && str[n] <= 'z') ||		  (str[n] >= '0' && str[n] <= '9') ||		  (str[n] == '-' || str[n] == '_' || str[n] == '.' ||		  str[n] == '~')) {			if (ret)				ret[len] = str[n];			len++;		} else {			if (ret) {				sprintf(ret + len, "%%%02X", str[n]);			}			len += 3;		}	}		if (ret) {		ret[len] = '\0';		return ret;	}			ret = xmalloc(len + 1);	if (ret == NULL) {		printf("http: Failed allocating %ld", len + 1);		return NULL;	}	len = 0;	goto encode;}struct http_request *http_get(const char *surl){	char *testHost;	struct url *url;	struct http_request *req;	size_t len, alen;	short err;	char ip_s[16];	ip_addr local_ip;	tcp_port local_port;	printf("surl %s\n", surl);		url = url_parse(surl);	if (url == NULL){		printf("URL is null\n");		return NULL;	} else {		printf("URL is not null, continuing on\n");	}		printf("Debug 1\n");	req = xmalloczero(sizeof(struct http_request));	if (req == NULL) {		printf("http: Failed allocating http_request\n");		return NULL;	}	printf("Debug 2\n");	req->url = url;	printf("Debug 2- req->url->host\n", req->url->host);	req->tcp_buf_size = (4 * 1500) + sizeof(req->chunk);	req->tcp_buf = xmalloc(req->tcp_buf_size);	printf("Debug 3\n");	if (req->tcp_buf == NULL) {		printf("http: Failed allocating tcp_buf\n");		xfree(&req);		return NULL;	}		printf("Debug 4\n");	err = _TCPCreate(&req->tcp_iopb, &req->tcp_stream, (Ptr)req->tcp_buf,	  req->tcp_buf_size, nil, nil, nil, false);	  printf("Debug 4.1\n");	if (err) {		printf("Debug 4.2\n");		printf("TCPCreate failed: %d\n", err);		goto error;	}	printf("Debug 5 - Before DNSResolveName() \n");		testHost = "www.google.com.au";	req->host_ip = 0xC0A85621;	req->url->port = 80;	/*	err = DNSResolveName(&req->url->host, &req->host_ip, NULL);		err = DNSResolveName(&testHost, &req->host_ip, NULL);		printf("Debug 6\n");	if (err) {		printf("Couldn't resolve host %s (%d)", req->url->host, err);		goto error;	}	*/printf("Debug 7\n");	printf("Debug 6\n");		long2ip(req->host_ip, (char *)&ip_s);printf("Debug 8\n");		local_port = 0;	err = _TCPActiveOpen(&req->tcp_iopb, req->tcp_stream, req->host_ip,	  req->url->port, &local_ip, &local_port, nil, nil, false);	if (err) {		printf("Failed connecting to %s (%s) port %d: %d",		  req->url->host, ip_s, req->url->port, err);		goto error;	}printf("Debug 9\n");	alen = 256 + strlen(req->url->host) + strlen(req->url->path);	req->message = xmalloc(alen);	if (req->message == NULL) {		printf("http: Failed allocating message");		goto error;	}	len = snprintf(req->message, alen,	  "GET %s HTTP/1.0\r\n"	  "Host: %s\r\n"	  "User-Agent: %s\r\n"	  "Accept: "	  "\r\n", req->url->path, req->url->host, PROGRAM_NAME);	if (len > alen)		panic("snprintf overflow");		printf("Debug 10\n");	memset(&req->tcp_wds, 0, sizeof(req->tcp_wds));	req->tcp_wds[0].ptr = req->message;	req->tcp_wds[0].length = len;	err = _TCPSend(&req->tcp_iopb, req->tcp_stream, req->tcp_wds, nil, nil,	  false);	if (err) {		printf("TCPSend to %s (%s) failed: %d", req->url->host, ip_s, err);		goto error;	}			return req;	error:	http_req_free(&req);	return NULL;}ssize_thttp_req_read(struct http_request *req, char *data, size_t len){	short err;	unsigned short rlen;		if (!req)		return -1;		err = _TCPStatus(&req->tcp_iopb, req->tcp_stream, &req->tcp_status_pb,	  nil, nil, false);	if (err)		return -1;			if (req->tcp_status_pb.amtUnreadData == 0)		return 0;		rlen = MIN(req->tcp_status_pb.amtUnreadData, len);	err = _TCPRcv(&req->tcp_iopb, req->tcp_stream, data, &rlen, nil, nil,	  false);	if (err)		return -1;		return rlen;}boolhttp_req_skip_header(struct http_request *req){	size_t len, n;	bool last_nl = false;		for (;;) {		if (req->chunk_len == sizeof(req->chunk))			/* this sure is a long header... */			req->chunk_len = 0;					len = http_req_read(req, req->chunk + req->chunk_len,		  sizeof(req->chunk) - req->chunk_len);		if (len < 0)			return false;		if (len == 0)			continue;		req->chunk_len += len;				for (n = 1; n < req->chunk_len; n++) {			if (req->chunk[n - 1] != '\r' || req->chunk[n] != '\n') {				last_nl = false;				continue;			}							/* newline, shift chunk back */			if (strncmp(req->chunk, "Content-Length: ", 16) == 0) {				if (sscanf(req->chunk, "Content-Length: %ld", &len) == 1)					req->content_len = len;			}			req->chunk_len -= n + 1;			memmove(req->chunk, req->chunk + n + 1, req->chunk_len);			req->chunk_off = 0;						if (last_nl)				return true;							last_nl = true;			n = 0; /* start at 1 on next iteration */		}	}		return false;}shorthttp_req_chunk_peek(void *cookie){	struct http_request *req = (struct http_request *)cookie;	if (req->chunk_len == 0 || (req->chunk_off + 1 > req->chunk_len)) {		req->chunk_len = http_req_read(req, req->chunk, sizeof(req->chunk));		req->chunk_off = 0;	}		if (req->chunk_len == 0 || (req->chunk_off + 1 > req->chunk_len))		return EOF;		return req->chunk[req->chunk_off];}shorthttp_req_chunk_read(void *cookie){	struct http_request *req = (struct http_request *)cookie;	short c;		c = http_req_chunk_peek(req);	if (c == EOF)		return c;	req->chunk_off++;		return c;}voidhttp_req_free(void *reqptr){	unsigned long *addr = (unsigned long *)reqptr;	void *ptr = (void *)*addr;	struct http_request *req = (struct http_request *)ptr;	if (req == NULL)		return;			_TCPRelease(&req->tcp_iopb, req->tcp_stream, nil, nil, false);	if (req->message != NULL)		xfree(&req->message);	xfree(&req->tcp_buf);	xfree(&req->url);	xfree(&req);		*addr = 0L;}