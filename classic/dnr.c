/* * DNR.c - DNR library for MPW * * (c) Copyright 1988 by Apple Computer.  All rights reserved *				 * Modifications by Jim Matthews, Dartmouth College, 5/91			 */#include <OSUtils.h>#include <Files.h>#include <Folders.h>#include <GestaltEqu.h>#include <Traps.h>#include <stdio.h>#include "AddressXlation.h"#include "tcp.h"#define OPENRESOLVER	1#define CLOSERESOLVER	2#define STRTOADDR		3#define ADDRTOSTR		4#define ENUMCACHE		5#define ADDRTONAME		6#define HINFO			7#define MXINFO			8TrapType GetTrapType(unsigned long theTrap);Boolean TrapAvailable(unsigned long trap);void GetSystemFolder(short *vRefNumP, long *dirIDP);void GetCPanelFolder(short *vRefNumP, long *dirIDP);short SearchFolderForDNRP(long targetType, long targetCreator,	short vRefNum, long dirID);short OpenOurRF(void);Handle dnr = nil;TrapTypeGetTrapType(unsigned long theTrap){	if (BitAnd(theTrap, 0x0800) > 0)		return (ToolTrap);	return (OSTrap);}BooleanTrapAvailable(unsigned long trap){	TrapType trapType = ToolTrap;	unsigned long numToolBoxTraps;	if (NGetTrapAddress(_InitGraf, ToolTrap) ==	  NGetTrapAddress(0xAA6E, ToolTrap))		numToolBoxTraps = 0x200;	else		numToolBoxTraps = 0x400;	trapType = GetTrapType(trap);	if (trapType == ToolTrap) {		trap = BitAnd(trap, 0x07FF);		if (trap >= numToolBoxTraps)			trap = _Unimplemented;	}		return (NGetTrapAddress(trap, trapType) !=	  NGetTrapAddress(_Unimplemented, ToolTrap));}voidGetSystemFolder(short *vRefNumP, long *dirIDP){	SysEnvRec info;	long wdProcID;		SysEnvirons(1, &info);	if (GetWDInfo(info.sysVRefNum, vRefNumP, dirIDP, &wdProcID) != noErr) {		*vRefNumP = 0;		*dirIDP = 0;	}}voidGetCPanelFolder(short *vRefNumP, long *dirIDP){	Boolean hasFolderMgr = false;	long feature;		if (TrapAvailable(_GestaltDispatch) &&	  Gestalt(gestaltFindFolderAttr, &feature) == noErr)		hasFolderMgr = true;	if (!hasFolderMgr) {		GetSystemFolder(vRefNumP, dirIDP);		return;	}	if (FindFolder(kOnSystemDisk, kControlPanelFolderType,	  kDontCreateFolder, vRefNumP, dirIDP) != noErr) {		*vRefNumP = 0;		*dirIDP = 0;	}}				/* * SearchFolderForDNRP is called to search a folder for files that might * contain the 'dnrp' resource */shortSearchFolderForDNRP(long targetType, long targetCreator, short vRefNum,  long dirID){	HParamBlockRec fi;	Str255 filename;	short refnum;					fi.fileParam.ioCompletion = nil;	fi.fileParam.ioNamePtr = (StringPtr)&filename;	fi.fileParam.ioVRefNum = vRefNum;	fi.fileParam.ioDirID = dirID;	fi.fileParam.ioFDirIndex = 1;					while (PBHGetFInfo(&fi, false) == noErr) {		/* scan system folder for driver resource files of specific type & creator */		if (fi.fileParam.ioFlFndrInfo.fdType == targetType &&		  fi.fileParam.ioFlFndrInfo.fdCreator == targetCreator) {			/* found the MacTCP driver file? */			refnum = HOpenResFile(vRefNum, dirID, filename, fsRdPerm);			if (Get1IndResource('dnrp', 1))				return refnum;			CloseResFile(refnum);		}				/* check next file in system folder */		fi.fileParam.ioFDirIndex++;		fi.fileParam.ioDirID = dirID; 	/* PBHGetFInfo() clobbers ioDirID */	}	return -1;} 			/* OpenOurRF is called to open the MacTCP driver resources */shortOpenOurRF(void){	short refnum;	short vRefNum;	long dirID;	/* first search Control Panels for MacTCP 1.1 */	GetCPanelFolder(&vRefNum, &dirID);	refnum = SearchFolderForDNRP('cdev', 'ztcp', vRefNum, dirID);	if (refnum != -1)		return (refnum);	/* next search System Folder for MacTCP 1.0.x */	GetSystemFolder(&vRefNum, &dirID);	refnum = SearchFolderForDNRP('cdev', 'mtcp', vRefNum, dirID);	if (refnum != -1)		return (refnum);	/* finally, search Control Panels for MacTCP 1.0.x */	GetCPanelFolder(&vRefNum, &dirID);	refnum = SearchFolderForDNRP('cdev', 'mtcp', vRefNum, dirID);	if (refnum != -1)		return (refnum);	return -1;}OSErrOpenResolver(char *fileName){	short refnum;	OSErr rc;					if (dnr != nil)		/* resolver already loaded in */		return (noErr);									/*	 * Open the MacTCP driver to get DNR resources. Search for it based on	 * creator & type rather than simply file name.	 */ 				refnum = OpenOurRF();	/*	 * Ignore failures since the resource may have been installed in the	 * System file if running on a Mac 512Ke.	 */						/* load in the DNR resource package */	ResrvMem(16000L); 			/* s-dorner@uiuc.edu, 9/5/91 */	dnr = Get1IndResource('dnrp', 1);	if (dnr == nil) {		/* can't open DNR */		return (ResError());	}					DetachResource(dnr);	if (refnum != -1) {		CloseWD(refnum);		CloseResFile(refnum);	}	/* lock the DNR resource since it cannot be relocated while opened */	MoveHHi(dnr);	HLock(dnr);		/* call open resolver */	rc = ((OpenResolverProcPtr)*dnr)(OPENRESOLVER, fileName);	if (rc != noErr) {		/* problem with open resolver, flush it */		HUnlock(dnr);		DisposHandle(dnr);		dnr = nil;	}		return (rc);}OSErrCloseResolver(void){	if (dnr == nil)		/* resolver not loaded error */		return (notOpenErr);									/* call close resolver */	(void)((CloseResolverProcPtr)*dnr)(CLOSERESOLVER);	/* release the DNR resource package */	HUnlock(dnr);	DisposHandle(dnr);	dnr = nil;		return (noErr);}OSErrStrToAddr(char *hostName, struct hostInfo *rtnStruct,  ResultProcPtr resultproc, char *userDataPtr){	OSErr err;		if (dnr == nil)		/* resolver not loaded error */		return (notOpenErr);	err = ((StrToAddrProcPtr)*dnr)(STRTOADDR, hostName, rtnStruct,	  resultproc, userDataPtr);	return err;}OSErrAddrToStr(unsigned long addr, char *addrStr)																																{	if (dnr == nil)		/* resolver not loaded error */		return (notOpenErr);									(void)((AddrToStrProcPtr)*dnr)(ADDRTOSTR, addr, addrStr);	return (noErr);}OSErrEnumCache(EnumResultProcPtr enumResultProc, char *userDataPtr){	if (dnr == nil)		/* resolver not loaded error */		return (notOpenErr);									return ((EnumCacheProcPtr)*dnr)(ENUMCACHE, enumResultProc,	  userDataPtr);}				OSErrAddrToName(ip_addr addr, struct hostInfo *hostInfoPtr,  ResultProcPtr resultProc, char *userDataPtr){	if (dnr == nil)		/* resolver not loaded error */		return (notOpenErr);	return ((AddrToNameProcPtr)*dnr)(ADDRTONAME, addr, hostInfoPtr,	  resultProc, userDataPtr);}#if 0OSErrHInfo(char *hostName, struct returnRec *returnRecPtr, long resultProc,  char *userDataPtr){	if (dnr == nil)		/* resolver not loaded error */		return (notOpenErr);				return ((*dnr)(HINFO, hostName, returnRecPtr, resultProc, userDataPtr));}				OSErrMXInfo(char *hostName, struct returnRec *returnRecPtr, long resultProc,  char *userDataPtr){	if (dnr == nil)		/* resolver not loaded error */		return (notOpenErr);									return ((*dnr)(MXINFO, hostName, returnRecPtr, resultProc, userDataPtr));}#endifOSErrDNSResolveName(char **name, unsigned long *ipAddress, void (*yielder)(void)){	OSErr osErr;	struct hostInfo aHostInfo;	volatile int done = 0;	osErr = OpenResolver(nil);	if (osErr)		return osErr;		osErr = StrToAddr(*name, &aHostInfo, (ResultProcPtr)StrToAddrMarkDone,	  (char *)&done);		if (osErr == cacheFault) {		/* StrToAddrMarkDone will set done when DNS resolution finishes */				while (!done) {			if (yielder != NULL){				yielder();			}		}			}	if ((aHostInfo.rtnCode == noErr) || (aHostInfo.rtnCode == cacheFault)) {		/* use the first IP address for this host */		*ipAddress = aHostInfo.addr[0];		osErr = noErr;	} else {		osErr = aHostInfo.rtnCode;	}	CloseResolver();	return osErr;}