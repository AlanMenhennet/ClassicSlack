#include <stdio.h>#include <string.h>#include "tcp.h"#include "sof_http.h"#include <stdlib.h>#define BUFFER_SIZE 4096/** * Given a domain name, send a DNS request to return * the IP address to send the request to */ip_addr sof_http_get_url(char *hostname) {	ip_addr remoteIP;	OSErr err;	unsigned long ipAddress = 0;		err = DNSResolveName(&hostname, &ipAddress, NULL);		if(err != noErr){		printf("couldn't resolve host err: %d\n", err);	} else {		char ipStr[16];		long2ip(ipAddress, ipStr);		printf("Resolve to: %s (0x%08lX)\n", ipStr, ipAddress);				remoteIP = ipAddress;			}	return remoteIP;}/** * This will take the response and split it after the eaders * only returning the body */void sof_get_body(char *buf, char **body) {	char *boundary = strstr(buf, "\r\n\r\n");		/* Content Boundary Not Found */		if(!boundary){		return;	}		boundary += 4; /* skip passed the boundary */	*body = malloc(strlen(boundary) + 1);	strcpy(*body, boundary);	}/** * Close and cleanup the connection */void sof_http_close(TCPiopb pb, StreamPtr stream) {	OSErr err;	printf("Closing Connection\n");		_TCPAbort(&pb, stream, nil, nil, true);	printf("Abort Completed\n");		err = _TCPRelease(&pb, stream, nil, nil, true);	printf("TCPRelease returned %d\n", err);		{			long endTime;		Delay(30, &endTime);	}		}/** * While _TCPStatus returns that there is more data, continue * to invoke _TCPRcv to read the response */void sof_http_read(TCPiopb pb, StreamPtr stream, TCPStatusPB status, 	char dataBuffer[], short *totalReceived) {	short bufferSize = 4096;	OSErr err;	short attempts =00;	short statusErr;	short maxAttempts = 20;	unsigned short rcvLen = 0;		printf("Starting attempts - max attempts is %d \n", maxAttempts);		while(attempts < maxAttempts && *totalReceived < bufferSize - 1){			err = _TCPStatus(&pb, stream, &status, nil, nil, false);			if(err != noErr){			break;		}			if(status.amtUnreadData < 512){			rcvLen = status.amtUnreadData;		} else {			rcvLen = 512;		}				printf("Starting _TCPRcv rcvLen is %d\n", rcvLen);				err = _TCPRcv(&pb, stream, dataBuffer + *totalReceived, &rcvLen, nil, nil, false);				if(rcvLen > 0){			*totalReceived = *totalReceived + rcvLen;		}						if(err == connectionDoesntExist){			printf("Connection Gone\n");			break;		}						if(rcvLen == 0 && err == connectionClosing){			printf("No more data, connection closing\n");			break;			}				if(err != noErr && err != connectionClosing){			printf("Error %d, stopping\n", err);			break;		}						attempts++;	}		dataBuffer[*totalReceived] = '\0';	}/** * Construct the string to send for the GET request, * then transmit with _TCPSend */void sof_http_send_get(TCPiopb pb, StreamPtr stream, char sendBuffer[], char *hostname) {	OSErr err;	wdsEntry wds[2];		sprintf(sendBuffer, 		"GET / HTTP/1.0\r\nHost: %s\r\nUser-Agent:Macintosh\r\n\r\n",		hostname);	printf("Sending request:\n%s\n", sendBuffer);		/* Setup write data structure */	wds[0].length = strlen(sendBuffer);	wds[0].ptr = sendBuffer;	wds[1].length = 0;		/* Send Request */	err = _TCPSend(&pb, stream, wds, nil, nil, false);			if(err != noErr){ 		printf("TCPSend failed: %d\n", err);		_TCPClose(&pb, stream, nil, nil, false);		_TCPRelease(&pb, stream, nil, nil, false);		return;	}		printf("Request Sent\n");}/** * Construct the string to transmit for the POST request * Then invoke _TCPSend() */void sof_http_send_post(TCPiopb pb, StreamPtr stream, 	char sendBuffer[], char *hostname, char *path, char *payload) {		wdsEntry wds[2];	OSErr err;	short contentLength = strlen(payload);		sprintf(sendBuffer, 		"POST %s HTTP/1.0\r\n"		"Host: %s\r\n"		"User-Agent:Macintosh\r\n"		"Content-Type: text/plain\r\n"		"Content-Length:%d\r\n"		"\r\n"		"%s",		path,		hostname,		contentLength,		payload	);	printf("Sending request:\n%s\n", sendBuffer);		/* Setup write data structure */	wds[0].length = strlen(sendBuffer);	wds[0].ptr = sendBuffer;	wds[1].length = 0; /* terminator */		/* Send Request */	err = _TCPSend(&pb, stream, wds, nil, nil, false);			if(err != noErr){		printf("TCPSend failed: %d\n", err);		_TCPClose(&pb, stream, nil, nil, false);		_TCPRelease(&pb, stream, nil, nil, false);		return;	}		printf("Request Sent\n");}/** * Initialize the TCP request */void sof_init(TCPiopb *pb, TCPStatusPB *status, 	StreamPtr *stream, char *rcvBuffer) {	OSErr err;	printf("Starting MacTCP\n");	err = _TCPInit();	if(err != noErr){		printf("TCPInit failed: %d\n", err);		return;	}		printf("Creating TCP stream..\n");	err = _TCPCreate(pb, stream, (Ptr)rcvBuffer, 4096, nil, nil,nil,false);	if(err != noErr){		printf("TCPInit Create: %d\n", err);		return;	}	printf("Stream created %d\n", stream);}/** * Send a GET request * the response body will we set to req->body */struct sof_request * sof_get(char *reqUrl){	ip_addr remoteIP, localIP;	tcp_port remotePort, localPort;	OSErr err;	static char sendBuffer[512];	static unsigned short rcvLen;	short totalReceived = 0;	static char dataBuffer[BUFFER_SIZE];		struct sof_url *url;	struct sof_request *req;		url = sof_url_parse(reqUrl);	req = malloc(sizeof(struct sof_request));	if(req != NULL){		memset(req, 0, sizeof(struct sof_request));	}		req->rcvBuffer = NewPtr(4098);		sof_init(&req->pb, &req->status, &req->stream, req->rcvBuffer);		/* DNS Resolution */	remoteIP = sof_http_get_url(url->hostname);		printf("REMOTE IP %d\n", remoteIP);		remotePort = 80;	localPort = 0;			printf("Connecting to server\n");	err = _TCPActiveOpen(&req->pb, req->stream, remoteIP, remotePort, &localIP, 		&localPort, nil, nil, false);			if(err != noErr){		printf("TCPActiveOpen failed: %d\n", err);		_TCPRelease(&req->pb, req->stream, nil, nil, false);		return;	}		printf("Connected!\n");	sof_http_send_get(req->pb, req->stream, sendBuffer, url->hostname);			printf("Receiving Response...\n");		sof_http_read(req->pb, req->stream, req->status, dataBuffer, &totalReceived);			if(totalReceived > 0){		printf("\n\n");		printf("Completed Response (%d bytes) \n", totalReceived);		printf("----------------------\n");		sof_get_body(dataBuffer, &req->body);		printf("----------------------\n");		printf("\n\n");	} else {		printf("Nothing Received\n");	}								/* If connection closed, that's expected after HTTP response */	if(err == connectionClosing || err == connectionDoesntExist){		printf("Connection closed by server (normal for HTTP/1.0)\n");	}		sof_http_close(req->pb, req->stream);		printf("Done\n");	return req;}/** * Send a POST request, the response body will we set to req->body */struct sof_request * sof_post(char *reqUrl, char *payload){	struct sof_request *req;	ip_addr remoteIP, localIP;	tcp_port remotePort, localPort;	OSErr err;	static char sendBuffer[512];	static unsigned short rcvLen;	short totalReceived = 0;	static char dataBuffer[BUFFER_SIZE];	struct sof_url *url;		url = sof_url_parse(reqUrl);		req = malloc(sizeof(struct sof_request));	if(req != NULL){		memset(req, 0, sizeof(struct sof_request));	}		req->rcvBuffer = NewPtr(4098);		sof_init(&req->pb, &req->status, &req->stream, req->rcvBuffer);		/* DNS Resolution */	remoteIP = sof_http_get_url(url->hostname);			printf("REMOTE IP %d\n", remoteIP);		remotePort = 80;	localPort = 0;		printf("connecting to server\n");	err = _TCPActiveOpen(&req->pb, req->stream, remoteIP, remotePort, &localIP, 		&localPort, nil, nil, false);			if(err != noErr){		printf("TCPActiveOpen failed: %d\n", err);		_TCPRelease(&req->pb, req->stream, nil, nil, false);		return;	}		printf("Connected!\n");	sof_http_send_post(req->pb, req->stream, sendBuffer, 		url->hostname, url->url, payload);			printf("Receiving Response...\n");		sof_http_read(req->pb, req->stream, req->status, dataBuffer, &totalReceived);			if(totalReceived > 0){		printf("\n\n");		printf("Completed Response (%d bytes) \n", totalReceived);		printf("----------------------\n");				sof_get_body(dataBuffer, &req->body);				printf("----------------------\n");		printf("\n\n");	} else {		printf("Nothing Received\n");	}								/* If connection closed, that's expected after HTTP response */	if(err == connectionClosing || err == connectionDoesntExist){		printf("Connection closed by server (normal for HTTP/1.0)\n");	}		sof_http_close(req->pb, req->stream);		printf("Done\n");	return req;}/** * Take a url like https://somedomain.com.au/path/relative * and return a struct holding the hostname (somedomain.com.au) * and the full url as passed */struct sof_url * sof_url_parse(char *surl) {	struct sof_url *url;	char hostname[256];	url = malloc(sizeof(struct sof_url));		if(sscanf(surl, "%*[^:]://%255[^/:]", hostname) == 1){			} else {		printf("failed to parse host\n");	}		strncpy(url->hostname, hostname, sizeof(url->hostname) -1);	url->hostname[sizeof(url->hostname) -1] = '\0';		strncpy(url->url, surl, sizeof(url->url) -1);	url->url[sizeof(url->url) -1] = '\0';		return url;}